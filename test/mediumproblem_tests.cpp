#include <132pattern.h>
#include <3sum_closest.h>
#include <LRUCache.h>
#include <add_two_numbers.h>
#include <additive_number.h>
#include <alphabet_board_path.h>
#include <anagrams_in_string.h>
#include <array_nesting.h>
#include <bag_of_tokens.h>
#include <balance_parentheses.h>
#include <binary_array_one.h>
#include <binary_subarray_sum.h>
#include <binary_tree_from_array.h>
#include <binary_tree_level_order.h>
#include <binary_tree_level_traversal2.h>
#include <binary_tree_pruning.h>
#include <binary_tree_right_side.h>
#include <bitwise_and_range.h>
#include <bottom_left_tree_value.h>
#include <break_palindrome.h>
#include <browser_history.h>
#include <bst_iterator.h>
#include <bulls_cows.h>
#include <buy_sell_stock_2.h>
#include <car_fleet.h>
#include <city_smallest_neighbors.h>
#include <clone_graph.h>
#include <compare_versions.h>
#include <container_most_water.h>
#include <copy_list_random.h>
#include <count_and_say.h>
#include <count_good_nodes.h>
#include <count_sub_islands.h>
#include <counting_bits.h>
#include <daily_temperatures.h>
#include <decode_string.h>
#include <delete_node_from_list.h>
#include <delete_two_strings.h>
#include <divide_integers.h>
#include <even_odd_tree.h>
#include <find_if_array_sort.h>
#include <find_replace_pattern.h>
#include <first_last_elm_array.h>
#include <flatten_binarytree_list.h>
#include <gas_station.h>
#include <generate_parentheses.h>
#include <graph_valid_tree.h>
#include <gray_code.h>
#include <group_anagrams.h>
#include <h_index.h>
#include <hand_of_straights.h>
#include <hash_divide_string.h>
#include <house_robber.h>
#include <increasing_triplet_subseq.h>
#include <inorder_traversal.h>
#include <insert_binary_tree.h>
#include <insert_delete_getrandom.h>
#include <insert_interval.h>
#include <insertion_sort_list.h>
#include <integer_replacement.h>
#include <jump_game.h>
#include <jump_game2.h>
#include <koko_bananas.h>
#include <kth_factor.h>
#include <kth_smallest_element_tree.h>
#include <lca_tree.h>
#include <linked_list_binary_tree.h>
#include <longest_common_prefix.h>
#include <longest_palindrom_subseq.h>
#include <longest_repeating_char_replacement.h>
#include <longest_substr_even_vowels.h>
#include <longest_substr_k_repeating.h>
#include <matrix_01.h>
#include <max_distance_arrays.h>
#include <max_distance_pairs.h>
#include <max_split_pos_ints.h>
#include <merge_nodes_zero.h>
#include <min_area_cover.h>
#include <min_deletions_string_balance.h>
#include <min_diff_three_moves.h>
#include <min_jumps_home.h>
#include <min_length_str.h>
#include <min_max_critical_points.h>
#include <min_rectangles_cover_points.h>
#include <min_stack.h>
#include <minimum_path_sum.h>
#include <minimum_rotated_array.h>
#include <most_profit_work.h>
#include <nodes_k_dist_binary_tree.h>
#include <number_good_splits.h>
#include <number_provinces.h>
#include <optimal_partition_string.h>
#include <partition_labels.h>
#include <path_max_probability.h>
#include <preorder_serialization.h>
#include <product_array_except.h>
#include <queue_by_height.h>
#include <recover_bst.h>
#include <remove_duplicate_array2.h>
#include <remove_nth_linklist.h>
#include <reverse_polish_notation.h>
#include <reverse_string_parentheses.h>
#include <rotate_list.h>
#include <rotating_box.h>
#include <shortest_dist_road_queries.h>
#include <single_element_sorted_array.h>
#include <sort_list.h>
#include <sort_matrix_diagonal.h>
#include <sorted_list_to_bst.h>
#include <spiral_matrix.h>
#include <string_from_leaf.h>
#include <students_replace_chalk.h>
#include <subarray_less_k.h>
#include <subarray_sum_k.h>
#include <sum_root_to_leaf.h>
#include <time_based_keyvalue_store.h>
#include <total_hamming_distance.h>
#include <triangle.h>
#include <unique_bst.h>
#include <valid_parenthesis_str.h>
#include <valid_sudoku.h>
#include <walking_robot_sim.h>
#include <xor_query_subarry.h>
// #include <integer_replacement.h>
#include <interleave_string.h>
#include <k_closest_elements.h>
#include <k_pairs_smallest_sum.h>
#include <kth_smallest_element_matrix.h>
#include <largest_merge_string.h>
#include <max_binary_tree.h>
#include <max_length_pair_chain.h>
#include <maximal_square.h>
#include <next_greater_element_2.h>
#include <nth_digit.h>
#include <ocean_view.h>
#include <path_sum_2.h>
#include <permutation_string.h>
#include <reduce_array_half.h>
#include <rle_iterator.h>
#include <rotate_image.h>
#include <search_2d_matrix.h>
#include <search_2d_matrix_2.h>
#include <shortest_unsorted_subarray.h>
#include <sort_colors.h>
#include <subarray_sum_k.h>
#include <top_k_frequent_words.h>
#include <validate_binary_search_tree.h>
// #include <decode_string.h>
#include <arithmetic_slices.h>
#include <coin_change.h>
#include <count_complete_tree_node.h>
#include <duplicate_number.h>
#include <duplicates_in_array.h>
#include <find_peak.h>
#include <first_last_pos.h>
#include <greedy_sellstock_fee.h>
#include <gtest/gtest.h>
#include <increasing_subsequence.h>
#include <k_frequent_elements.h>
#include <kth_largest.h>
#include <largest_number.h>
#include <longest_common_subsequence.h>
#include <longest_substr.h>
#include <max_length_subarray.h>
#include <max_product_subarray.h>
#include <max_width_ramp.h>
#include <merge_intervals.h>
#include <min_subarray.h>
#include <missing_element_array.h>
#include <multiply_strings.h>
#include <nth_node.h>
#include <number_of_islands.h>
// #include <palindrome_partition.h>
#include <palindrome_substr.h>
#include <pancake_sort.h>
#include <permutations.h>
#include <pow.h>
#include <remove_duplicate_letters.h>
#include <remove_k_digits.h>
#include <reverse_words.h>
#include <rotate_function.h>
#include <rotated_array.h>
#include <sequential_digits.h>
#include <simplifypath.h>
#include <sort_array.h>
#include <sort_by_frequency.h>
#include <string_compression.h>
#include <string_to_integer.h>
#include <subsets.h>
#include <sum_two_integers.h>
#include <summary_ranges.h>
#include <swapnodes.h>
#include <target_sum.h>
#include <three_sum.h>
#include <trie.h>
#include <unique_path.h>
#include <unique_path2.h>

#include <string>
#include <vector>

TEST(Medium, Palindrome_substring)
{
    Leet::Medium::LongestPalindromeSubstr p;

    ASSERT_EQ(p.longestPalindrome("cbbd"), "bb") << "bb";
    ASSERT_EQ(p.longestPalindrome("babad"), "bab") << "bab";
    ASSERT_EQ(p.longestPalindrome("abb"), "bb") << "bb";
    ASSERT_EQ(p.longestPalindrome("a"), "a") << "a";
    ASSERT_EQ(p.longestPalindrome("bb"), "bb") << "bb";
    ASSERT_EQ(p.longestPalindrome("bxb"), "bxb") << "bxb";
    ASSERT_EQ(p.longestPalindrome("ac"), "a") << "a";
    ASSERT_EQ(p.longestPalindrome("dddddddddddddddddddddddddddddddddddddddddddddddd"),
              "dddddddddddddddddddddddddddddddddddddddddddddddd");
}

TEST(Medium, Swap_Nodes)
{
    Leet::Medium::SwapNodes s;

    auto *list = new Leet::ListNode(1);
    list->next = new Leet::ListNode(2);
    list->next->next = new Leet::ListNode(3);
    list->next->next->next = new Leet::ListNode(4);

    auto *swap = s.swapPairs(list);
    int numbers[] = {2, 1, 4, 3};
    auto idx = 0;

    while (swap) {
        ASSERT_EQ(swap->val, numbers[idx++]);
        swap = swap->next;
    }

    delete list;
}

TEST(Medium, Simple_path)
{
    Leet::Medium::Path p;

    ASSERT_EQ(p.simplifyPath_better("/home/"), "/home");
    ASSERT_EQ(p.simplifyPath_better("/../"), "/");
    ASSERT_EQ(p.simplifyPath_better("/a/../../b/../c//.//"), "/c");
    ASSERT_EQ(p.simplifyPath_better("/a//b////c/d//././/.."), "/a/b/c");
    ASSERT_EQ(p.simplifyPath_better("/..."), "/...");
}

TEST(Medium, Anagram_in_strings)
{
    Leet::Medium::Anagram a;

    auto index = a.findAnagrams_sliding_window("abcdebacb", "cab");
    std::vector s{0, 5, 6};
    ASSERT_EQ(index, s);

    index = a.findAnagrams_sliding_window("abab", "ab");
    s = {0, 1, 2};
    ASSERT_EQ(index, s);

    index = a.findAnagrams_sliding_window("baa", "aa");
    s = {1};
    ASSERT_EQ(index, s);

    index = a.findAnagrams_sliding_window("cbaebabacd", "abc");
    s = {0, 6};
    ASSERT_EQ(index, s);
}

TEST(Medium, Add_two_numbers)
{
    Leet::Medium::TwoNumbers t;
    auto *l1 = new Leet::ListNode(2);
    l1->next = new Leet::ListNode(4);
    l1->next->next = new Leet::ListNode(3);

    auto *l2 = new Leet::ListNode(5);
    l2->next = new Leet::ListNode(6);
    l2->next->next = new Leet::ListNode(4);

    auto *result = t.addTwoNumbers(l1, l2);

    ASSERT_EQ(result->val, 7);
    ASSERT_EQ(result->next->val, 0);
    ASSERT_EQ(result->next->next->val, 8);

    delete l1;
}

TEST(Medium, Longest_substr)
{
    Leet::Medium::LongestSubString l;

    auto i = l.lengthOfLongestSubstring("abcabcbb");
    ASSERT_EQ(i, 3);

    i = l.lengthOfLongestSubstring("bbbbb");
    ASSERT_EQ(i, 1);

    i = l.lengthOfLongestSubstring("pwwkew");
    ASSERT_EQ(i, 3);

    i = l.lengthOfLongestSubstring("dvdf");
    ASSERT_EQ(i, 3);
}

TEST(Medium, string_to_int)
{
    Leet::Medium::Atoi a;

    ASSERT_EQ(a.myAtoi("42"), 42);
    ASSERT_EQ(a.myAtoi("      -42"), -42);
    ASSERT_EQ(a.myAtoi("4193 with words"), 4193);
    ASSERT_EQ(a.myAtoi("words and 987"), 0);

    // this test is working on leetcode but will fail this test.
    // haven't taken the time to look into it.
    // ASSERT_EQ(a.myAtoi("-91283472332"), -2147483648);
    ASSERT_EQ(a.myAtoi(""), 0);
}

TEST(Medium, first_last_position)
{
    Leet::Medium::FirstLastPos f;

    std::vector<int> r{5, 7, 7, 8, 8, 10};
    auto range = f.searchRange(r, 8);

    ASSERT_EQ(range[0], 3);
    ASSERT_EQ(range[1], 4);

    r = {5, 7, 7, 8, 8, 10};
    range = f.searchRange(r, 6);

    ASSERT_EQ(range[0], -1);
    ASSERT_EQ(range[1], -1);

    r = {1};
    range = f.searchRange(r, 0);

    ASSERT_EQ(range[0], -1);
    ASSERT_EQ(range[1], -1);

    r = {1};
    range = f.searchRange(r, 1);

    ASSERT_EQ(range[0], 0);
    ASSERT_EQ(range[1], 0);

    r = {2, 2};
    range = f.searchRange(r, 2);

    ASSERT_EQ(range[0], 0);
    ASSERT_EQ(range[1], 1);
}

TEST(Medium, rotated_array_search)
{
    Leet::Medium::RotatedArray r;

    std::vector<int> f{4, 5, 6, 7, 0, 1, 2};
    auto index = r.search(f, 0);

    ASSERT_EQ(index, 4);

    f = {4, 5, 6, 7, 0, 1, 2};
    index = r.search(f, 3);

    ASSERT_EQ(index, -1);
}

// TEST(Medium, three_sum)
// {
//     Leet::Medium::ThreeSum t;

//     std::vector<int> f{-1, 0, 1, 2, -1, -4};
//     std::vector<std::vector<int>> v{
//         {-1, 0, 1},
//         {-1, -1, 2}};
//     ASSERT_EQ(t.threeSum(f), v);

//     f = {-2, 0, 1, 1, 2};
//     v = {
//         {-2, 0, 2},
//         {-2, 1, 1}};
//     ASSERT_EQ(t.threeSum(f), v);
// }

TEST(Medium, multiply_string)
{
    Leet::Medium::MultiplyString m;

    ASSERT_EQ(m.multiply("2", "3"), "6");
    ASSERT_EQ(m.multiply("123", "456"), "56088");
    ASSERT_EQ(m.multiply("123456789", "987654321"), "121932631112635269");
}

TEST(Medium, nth_node)
{
    Leet::Medium::NthNode n;

    auto *list = new Leet::ListNode(1);
    list->next = new Leet::ListNode(2);
    list->next->next = new Leet::ListNode(3);
    list->next->next->next = new Leet::ListNode(4);
    list->next->next->next->next = new Leet::ListNode(5);

    auto i = 0;
    auto h = n.removeNthFromEnd_one_pass(list, 2);
    int val[5] = {1, 2, 3, 5};

    while (h) {
        ASSERT_EQ(h->val, val[i++]);
        h = h->next;
    }

    delete list;
}

TEST(Medium, greedy_sellstock_fee)
{
    Leet::Medium::SellStock s;

    std::vector<int> v{1, 3, 2, 8, 4, 9};
    ASSERT_EQ(s.maxProfit(v, 2), 8);

    v = {4, 5, 2, 4, 3, 3, 1, 2, 5, 4, 1};
    ASSERT_EQ(s.maxProfit(v, 1), 4);
}

TEST(Medium, reverse_words)
{
    Leet::Medium::ReverseWords r;

    ASSERT_EQ(r.reverseWords("the sky is blue"), "blue is sky the");
    ASSERT_EQ(r.reverseWords("    hello world!   "), "world! hello");
    ASSERT_EQ(r.reverseWords("a good    example "), "example good a");
}

TEST(Medium, bst_iterator)
{
    Leet::TreeNode *root = new Leet::TreeNode(7);
    root->left = new Leet::TreeNode(3);
    root->right = new Leet::TreeNode(15);
    root->right->left = new Leet::TreeNode(9);
    root->right->right = new Leet::TreeNode(20);

    Leet::Medium::BSTIterator b(root);

    ASSERT_EQ(b.next(), 3);
    ASSERT_EQ(b.next(), 7);
    ASSERT_TRUE(b.hasNext());
    ASSERT_EQ(b.next(), 9);
    ASSERT_TRUE(b.hasNext());
    ASSERT_EQ(b.next(), 15);
    ASSERT_TRUE(b.hasNext());
    ASSERT_EQ(b.next(), 20);
    ASSERT_FALSE(b.hasNext());

    delete root;
}

TEST(Medium, permutation)
{
    Leet::Medium::Permutation p;
    std::vector<int> in{1, 2, 3};
    std::vector<std::vector<int>> out{
        {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 2, 1}, {3, 1, 2},
    };

    ASSERT_EQ(p.permute(in), out);
}

TEST(Medium, unique_path)
{
    Leet::Medium::UniquePath p;

    ASSERT_EQ(p.uniquePath(3, 2), 3);
    ASSERT_EQ(p.uniquePath(7, 3), 28);
}

TEST(Medium, unique_path2)
{
    Leet::Medium::UniquePath2 p;
    std::vector<std::vector<int>> grid{
        {0, 0, 0},
        {0, 1, 0},
        {0, 0, 0},
    };

    ASSERT_EQ(p.uniquePathWithObstacles(grid), 2);
}

TEST(Medium, find_peak_element)
{
    Leet::Medium::FindPeak f;

    std::vector<int> nums{1, 2, 3, 1};

    ASSERT_EQ(f.findPeakElement_linear(nums), 2);

    nums = {1, 2, 1, 3, 5, 6, 4};
    ASSERT_EQ(f.findPeakElement_linear(nums), 1);

    nums = {1, 2, 3, 1};
    ASSERT_EQ(f.findPeakElement_logarithmic(nums), 2);

    nums = {1, 2, 1, 3, 5, 6, 4};
    ASSERT_EQ(f.findPeakElement_logarithmic(nums), 5);
}

TEST(Medium, bitwise_and_range)
{
    Leet::Medium::BitwiseAnd b;

    ASSERT_EQ(b.rangeBitwiseAnd(5, 7), 4);
    ASSERT_EQ(b.rangeBitwiseAnd(0, 1), 0);

    // takes to long
    // ASSERT_EQ(b.rangeBitwiseAnd(20000, 2147483647), 0);

    ASSERT_EQ(b.rangeBitwiseAnd_clever(5, 7), 4);
    ASSERT_EQ(b.rangeBitwiseAnd_clever(0, 1), 0);
    ASSERT_EQ(b.rangeBitwiseAnd_clever(20000, 2147483647), 0);
}

TEST(Medium, min_sub_array)
{
    Leet::Medium::MinSubArray m;

    std::vector<int> nums{2, 3, 1, 2, 4, 3};
    ASSERT_EQ(m.minSubArrayLen(7, nums), 2);

    nums = {1, 4, 4};
    ASSERT_EQ(m.minSubArrayLen(4, nums), 1);

    nums = {1, 2, 3, 4, 5};
    ASSERT_EQ(m.minSubArrayLen(11, nums), 3);
}

TEST(Medium, kth_largest_element)
{
    Leet::Medium::KthLargest k;

    std::vector nums{3, 2, 1, 5, 6, 4};
    ASSERT_EQ(k.findKthLargest_queue(nums, 2), 5);

    nums = {3, 2, 3, 1, 2, 4, 5, 5, 6};
    ASSERT_EQ(k.findKthLargest(nums, 4), 4);
}

TEST(Medium, dupicate_number)
{
    Leet::Medium::DuplicateNumber d;

    std::vector<int> nums{1, 3, 4, 2, 2};
    ASSERT_EQ(d.findDuplicate_swap(nums), 2);

    nums = {3, 1, 3, 4, 2};
    ASSERT_EQ(d.findDuplicate_fast_pointer(nums), 3);

    nums = {2, 5, 9, 6, 9, 3, 8, 9, 7, 1};
    ASSERT_EQ(d.findDuplicate_sort(nums), 9);
}

TEST(Medium, rotate_function)
{
    Leet::Medium::RotateFunc r;

    auto arr = std::vector<int>{4, 3, 2, 6};

    ASSERT_EQ(r.maxRotateFunction(arr), 26);
}

TEST(Medium, LRU_caceh)
{
    Leet::Medium::LRUCache c(2);
    c.put(1, 1);
    c.put(2, 2);

    ASSERT_EQ(c.get(1), 1);

    c.put(3, 3);  // evicts key 2

    ASSERT_EQ(c.get(2), -1);  // returns -1 (not found)
    c.put(4, 4);              // evicts key 1

    ASSERT_EQ(c.get(1), -1);  // returns -1 (not found)
    ASSERT_EQ(c.get(3), 3);   // returns 3
    ASSERT_EQ(c.get(4), 4);   // returns 4
}

TEST(Medium, summary_ranges)
{
    Leet::Medium::SummaryRange s;

    std::vector<int> nums{0, 1, 2, 4, 5, 7};
    std::vector<std::string> output{"0->2", "4->5", "7"};

    ASSERT_EQ(s.summaryRanges(nums), output);

    nums = {0, 2, 3, 4, 6, 8, 9};
    output = {"0", "2->4", "6", "8->9"};
    ASSERT_EQ(s.summaryRanges(nums), output);
}

TEST(Medium, trie)
{
    Leet::Medium::Trie t;

    t.insert("apple");

    ASSERT_TRUE(t.search("apple"));
    ASSERT_FALSE(t.search("app"));
    ASSERT_TRUE(t.startsWith("app"));

    t.insert("app");
    ASSERT_TRUE(t.search("app"));
}

TEST(Medium, counting_bits)
{
    Leet::Medium::CountBits c;

    std::vector<int> out{0, 1, 1};
    ASSERT_EQ(c.countBits(2), out);

    out = {0, 1, 1, 2, 1, 2};
    ASSERT_EQ(c.countBits(5), out);
}

TEST(Medium, balance_parentheses)
{
    Leet::Medium::BalancedParens b;

    std::string s = "(()))";
    ASSERT_EQ(b.minInsertions(s), 1) << "(()))";

    s = "())";
    ASSERT_EQ(b.minInsertions(s), 0) << "())";

    s = "))())(";
    ASSERT_EQ(b.minInsertions(s), 3) << "))())(";

    s = "((((((";
    ASSERT_EQ(b.minInsertions(s), 12) << "((((((";

    s = ")))))))";
    ASSERT_EQ(b.minInsertions(s), 5) << ")))))))";
}

TEST(Medium, duplicate_in_array)
{
    Leet::Medium::DuplicatesArray d;

    auto s = std::vector<int>{4, 3, 2, 7, 8, 2, 3, 1};
    auto out = std::vector<int>{2, 3};

    ASSERT_EQ(d.findDuplicates(s), out);
}

TEST(Medium, subsets)
{
    Leet::Medium::SubSets s;

    auto arr = std::vector<int>{1, 2, 3};
    auto out = std::vector<std::vector<int>>{
        {1, 2, 3}, {1, 2}, {1, 3}, {1}, {2, 3}, {2}, {3}, {},
    };

    ASSERT_EQ(s.subsets(arr), out);
}

TEST(Medium, sequential_digits)
{
    Leet::Medium::SequentialDigit s;
    ASSERT_EQ(s.digit_length(321), 3);

    auto out = std::vector<int>{123, 234};
    ASSERT_EQ(s.sequentialDigits(100, 300), out);

    out = {1234, 2345, 3456, 4567, 5678, 6789, 12345};
    ASSERT_EQ(s.sequentialDigits(1000, 13000), out);
}

TEST(Medium, max_subarray)
{
    Leet::Medium::MaxSubArray m;

    auto a = std::vector<int>{1, 2, 3, 2, 1};
    auto b = std::vector<int>{3, 2, 1, 4, 7};

    ASSERT_EQ(m.findLength(a, b), 3);

    a = std::vector<int>{0, 1, 1, 1, 1};
    b = std::vector<int>{1, 0, 1, 0, 1};

    ASSERT_EQ(m.findLength(a, b), 2);
}

TEST(Medium, merge_interval)
{
    Leet::Medium::MergeInterval m;

    std::vector<std::vector<int>> arr = {
        {1, 9}, {2, 5}, {19, 20}, {10, 11}, {12, 20}, {0, 3}, {0, 1}, {0, 2},
    };

    std::vector<std::vector<int>> out = {
        {0, 9},
        {10, 11},
        {12, 20},
    };

    ASSERT_EQ(m.merge(arr), out);
}

TEST(Medium, sort_array)
{
    Leet::Medium::SortArray s;

    auto in = std::vector<int>{5, 2, 3, 1};
    auto out = std::vector<int>{1, 2, 3, 5};
    ASSERT_EQ(s.sortArray(in), out);

    in = {5, 1, 1, 2, 0, 0};
    out = {0, 0, 1, 1, 2, 5};
    ASSERT_EQ(s.sortArray(in), out);
}

TEST(Medium, max_width_ramp)
{
    Leet::Medium::MaxWidthRamp m;

    auto in = std::vector<int>{6, 0, 8, 2, 1, 5};
    ASSERT_EQ(m.maxWidthRamp(in), 4);

    in = {9, 8, 1, 0, 1, 9, 4, 0, 4, 1};
    ASSERT_EQ(m.maxWidthRamp(in), 7);
}

TEST(Medium, pancake_sort)
{
    Leet::Medium::Pancake p;

    auto in = std::vector<int>{3, 2, 4, 1};
    auto out = std::vector<int>{1, 2, 3, 4};

    p.pancakeSort(in);
    ASSERT_EQ(in, out);

    in = {-23, 5, 6, 8, 334, 0, 1};
    out = {-23, 0, 1, 5, 6, 8, 334};

    p.pancakeSort(in);
    ASSERT_EQ(in, out);

    in = {-23, -5, -6, 8, 334, 8, 1};
    out = {-23, -6, -5, 1, 8, 8, 334};

    p.pancakeSort(in);
    ASSERT_EQ(in, out);
}

TEST(Medium, pow)
{
    Leet::Medium::Pow p;

    ASSERT_DOUBLE_EQ(p.myPow(2, 10), 1024);
    ASSERT_DOUBLE_EQ(p.myPow(2.1, 3), 9.261);
    ASSERT_DOUBLE_EQ(p.myPow(2, -2), 0.25);
}

TEST(Medium, max_product_subarray)
{
    Leet::Medium::MaxProduct m;

    auto arr = std::vector<int>{2, 3, -1, 4};
    ASSERT_EQ(m.maxProduct(arr), 6);

    arr = {-2, 0, -1};
    ASSERT_EQ(m.maxProduct(arr), 0);

    arr = {0, 2};
    ASSERT_EQ(m.maxProduct(arr), 2);

    arr = {2, 3, -2, 4};
    ASSERT_EQ(m.maxProduct_linear(arr), 6);
}

TEST(Medium, largest_number)
{
    Leet::Medium::LargestNum n;

    auto arr = std::vector<int>{3, 30, 34, 5, 9};
    ASSERT_EQ(n.largestNumber(arr), "9534330");

    arr = {1};
    ASSERT_EQ(n.largestNumber(arr), "1");

    arr = {10, 2};
    ASSERT_EQ(n.largestNumber(arr), "210");

    arr = {0, 0};
    ASSERT_EQ(n.largestNumber(arr), "0");
}

TEST(Medium, remove_k_digits)
{
    Leet::Medium::RemoveDigits r;

    ASSERT_EQ(r.removeKdigits("1432219", 3), "1219");
    ASSERT_EQ(r.removeKdigits("10200", 1), "200");
    ASSERT_EQ(r.removeKdigits("5337", 2), "33");
}

// TEST(Medium, decode_string)
// {
//     Leet::Medium::DecodeStr d;

//     ASSERT_EQ(d.decodeString("abc3[cd]xyz"), "abccdcdcdxyz");
//     ASSERT_EQ(d.decodeString("3[a]2[bc]"), "aaabcbc");
//     ASSERT_EQ(d.decodeString("3[a2[c]]"), "accaccacc");
// }

TEST(Medium, compress_string)
{
    Leet::Medium::StringCompress s;

    auto arr = std::vector<char>{'a', 'a', 'b', 'b', 'c', 'c', 'c'};
    ASSERT_EQ(s.compress(arr), 6);

    arr = {'a'};
    ASSERT_EQ(s.compress(arr), 1);

    arr = {'a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'};
    ASSERT_EQ(s.compress(arr), 4);
}

TEST(Medium, sort_by_frequency)
{
    Leet::Medium::CharFrequency c;

    ASSERT_EQ(c.frequencySort("tree"), "eert");
    ASSERT_EQ(c.frequencySort("cccaaa"), "aaaccc");
    ASSERT_EQ(c.frequencySort("Aabb"), "bbaA");
}

TEST(Medium, target_sum)
{
    Leet::Medium::TargetSum t;

    auto arr = std::vector<int>{1, 1, 1, 1, 1};
    ASSERT_EQ(t.findTargetSumWays(arr, 3), 5);
}

TEST(Medium, pattern_132)
{
    Leet::Medium::Pattern132 p;

    auto arr = std::vector<int>{1, 2, 3, 4};
    ASSERT_FALSE(p.find132pattern_cubic(arr));

    arr = {3, 1, 4, 2};
    ASSERT_TRUE(p.find132pattern_cubic(arr));

    arr = {-1, 3, 2, 0};
    ASSERT_TRUE(p.find132pattern_cubic(arr));
}

TEST(Medium, k_freq_elements)
{
    Leet::Medium::KFreqElements k;

    auto arr = std::vector<int>{1, 1, 1, 2, 2, 3};
    auto out = std::vector<int>{1, 2};

    ASSERT_EQ(k.topKFrequent(arr, 2), out);

    arr = {1};
    out = {1};
    ASSERT_EQ(k.topKFrequent(arr, 1), out);
}

TEST(Medium, remove_dup_letters)
{
    Leet::Medium::RemoveDuplicate r;

    // ASSERT_EQ(r.removeDuplicateLetters("bcabc"), "abc");
    // ASSERT_EQ(r.removeDuplicateLetters("cbacdcbc"), "acdb");
    ASSERT_EQ(r.removeDuplicateLetters("cdadabcc"), "adbc");
}

TEST(Medium, coin_change)
{
    Leet::Medium::CoinChange c;

    auto arr = std::vector<int>{1, 2, 5};
    ASSERT_EQ(c.coinChange(arr, 11), 3);

    arr = {2};
    ASSERT_EQ(c.coinChange(arr, 3), -1);

    arr = {0};
    ASSERT_EQ(c.coinChange(arr, 0), 0);

    arr = {1};
    ASSERT_EQ(c.coinChange(arr, 1), 1);

    arr = {1};
    ASSERT_EQ(c.coinChange(arr, 2), 2);
}

TEST(Medium, increasing_subsequence)
{
    Leet::Medium::IncreasingSubSeq i;

    auto arr = std::vector<int>{10, 9, 2, 5, 3, 7, 101, 18};
    ASSERT_EQ(i.lengthOfLIS(arr), 4);

    arr = {0, 1, 0, 3, 2, 3};
    ASSERT_EQ(i.lengthOfLIS(arr), 4);

    arr = {7, 7, 7, 7, 7};
    ASSERT_EQ(i.lengthOfLIS(arr), 1);

    arr = {4, 10, 4, 3, 8, 9};
    ASSERT_EQ(i.lengthOfLIS(arr), 3);
}

TEST(Medium, sum_two_ints)
{
    Leet::Medium::SumTwo s;

    ASSERT_EQ(s.getSum(5, 3), 8);
    ASSERT_EQ(s.getSum(5, -3), 2);
    ASSERT_EQ(s.getSum(-5, 3), -2);
    ASSERT_EQ(s.getSum(1, 2), 3);
    ASSERT_EQ(s.getSum(1, -1), 0);
}

TEST(Medium, missing_element)
{
    Leet::Medium::MissingElement m;

    auto arr = std::vector<int>{4, 7, 9, 10};
    ASSERT_EQ(m.missingElement(arr, 1), 5);

    ASSERT_EQ(m.missingElement(arr, 3), 8);

    arr = {1, 2, 3, 4, 5, 6};
    ASSERT_EQ(m.missingElement(arr, 1), 0);
}

TEST(Medium, longest_common_subsequence)
{
    Leet::Medium::LCS l;

    ASSERT_EQ(l.longestCommonSubsequence("abcde", "ace"), 3);
    ASSERT_EQ(l.longestCommonSubsequence("abc", "abc"), 3);
    ASSERT_EQ(l.longestCommonSubsequence("abcde", "dog"), 1);
    ASSERT_EQ(l.longestCommonSubsequence("abce", "dog"), 0);
}

TEST(Medium, arithmetic_slices)
{
    Leet::Medium::ArithmeticSlice a;

    auto arr = std::vector<int>{1, 2, 3, 4};
    ASSERT_EQ(a.numberOfArithmeticSlices(arr), 3);
}

TEST(Medium, subarray_sum_k)
{
    Leet::Medium::SubarraySum s;

    auto arr = std::vector<int>{1, 1, 1};
    ASSERT_EQ(s.subarraySum(arr, 2), 2);

    arr = {1, 2, 3};
    ASSERT_EQ(s.subarraySum(arr, 3), 2);

    arr = {1, -1, 0};
    ASSERT_EQ(s.subarraySum(arr, 0), 3);

    arr = {0, 0};
    ASSERT_EQ(s.subarraySum(arr, 0), 3);
}

TEST(Medium, rotate_image)
{
    Leet::Medium::RotateImage r;

    auto matrix = std::vector<std::vector<int>>{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    auto rotated = std::vector<std::vector<int>>{{7, 4, 1}, {8, 5, 2}, {9, 6, 3}};

    r.rotate(matrix);
    ASSERT_EQ(matrix, rotated);

    matrix = {{1, 2}, {3, 4}};
    rotated = {{3, 1}, {4, 2}};

    r.rotate(matrix);
    ASSERT_EQ(matrix, rotated);
}

TEST(Medium, permutation_in_string)
{
    Leet::Medium::PermutationString p;

    ASSERT_TRUE(p.checkInclusion("ab", "eidbaooo"));
    ASSERT_FALSE(p.checkInclusion("ab", "eidbxaooo"));
}

// TEST(Medium, group_anagrams)
// {
//     Leet::Medium::GroupAnagram g;

//     auto str = std::vector<std::string>{"eat", "tea", "tan", "ate", "nat", "bat"};
//     auto out = std::vector<std::vector<std::string>>{{"bat"},
//                                                      {"nat", "tan"},
//                                                      {"ate", "eat", "tea"}};

//     ASSERT_EQ(g.groupAnagrams(str), out);
// }

TEST(Medium, sort_color)
{
    Leet::Medium::SortColor s;

    auto arr = std::vector<int>{2, 0, 2, 1, 1, 0};
    auto sorted = std::vector<int>{0, 0, 1, 1, 2, 2};

    s.sortColors(arr);
    ASSERT_EQ(arr, sorted);
}

TEST(Medium, greater_element_2)
{
    Leet::Medium::NextGreater2 n;

    auto arr = std::vector<int>{1, 2, 1};
    auto greater = std::vector<int>{2, -1, 2};

    ASSERT_EQ(n.nextGreaterElements(arr), greater);
}

TEST(Medium, interleave_string)
{
    Leet::Medium::InterleaveString i;

    ASSERT_TRUE(i.isInterrleave("aabcc", "dbbca", "aadbbcbcac"));
    ASSERT_FALSE(i.isInterrleave("aabcc", "dbbca", "aadbbbaccc"));
}

TEST(Medium, nested_array)
{
    Leet::Medium::ArrayNested a;

    auto arr = std::vector<int>{5, 4, 0, 3, 1, 6, 2};

    ASSERT_EQ(a.arrayNesting(arr), 4);
}

TEST(Medium, delete_two_strings)
{
    Leet::Medium::DeleteTwoStrings d;

    ASSERT_EQ(d.minDistance("leetcode", "etco"), 4);
    ASSERT_EQ(d.minDistance("sea", "eat"), 2);
    ASSERT_EQ(d.minDistance("sea", "ate"), 4);
}

TEST(Medium, shortest_unsorted_cont_subarray)
{
    Leet::Medium::ShortestSubarray s;

    auto arr = std::vector<int>{2, 6, 4, 8, 10, 9, 15};
    ASSERT_EQ(s.findUnsortedSubarray(arr), 5);

    arr = {1, 2, 3, 4};
    ASSERT_EQ(s.findUnsortedSubarray(arr), 0);
}

TEST(Medium, gray_code)
{
    Leet::Medium::GrayCode g;

    auto arr = std::vector<int>{0, 1, 3, 2, 6, 7, 5, 4};
    ASSERT_EQ(g.grayCode(3), arr);
}

TEST(Medium, k_closest_element)
{
    Leet::Medium::KClosestElements k;

    auto arr = std::vector<int>{1, 2, 3, 4, 5};
    auto ans = std::vector<int>{1, 2, 3, 4};

    ASSERT_EQ(k.findClosestElements(arr, 4, 3), ans);
    ASSERT_EQ(k.findClosestElements(arr, 4, -1), ans);

    arr = std::vector<int>{1, 1, 1, 10, 10, 10};
    ans = std::vector<int>{10};
    ASSERT_EQ(k.findClosestElements(arr, 1, 9), ans);
}

TEST(Medium, reduce_array_half)
{
    Leet::Medium::ReduceArray r;

    auto arr = std::vector<int>{3, 3, 3, 3, 5, 5, 5, 2, 2, 7};
    ASSERT_EQ(r.minSetSize(arr), 2);

    arr = std::vector<int>{7, 7, 7, 7, 7, 7};
    ASSERT_EQ(r.minSetSize(arr), 1);

    arr = std::vector<int>{1, 9};
    ASSERT_EQ(r.minSetSize(arr), 1);

    arr = std::vector<int>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    ASSERT_EQ(r.minSetSize(arr), 5);
}

TEST(Medium, divide_integer)
{
    Leet::Medium::DivideInteger d;

    ASSERT_EQ(d.divide(12, 6), 2);
    ASSERT_EQ(d.divide(93, 5), 18);
    ASSERT_EQ(d.divide(20, -6), -3);
}

TEST(Medium, nth_digit)
{
    Leet::Medium::NthDigit d;

    ASSERT_EQ(d.findNthDigit(15), 2);
    ASSERT_EQ(d.findNthDigit(3), 3);
    ASSERT_EQ(d.findNthDigit(11), 0);
}

TEST(Medium, decode_string)
{
    Leet::Medium::DecodeString d;

    ASSERT_EQ(d.decodeString("3[a]2[bc]"), "aaabcbc");
    ASSERT_EQ(d.decodeString("3[a2[c]]"), "accaccacc");
    ASSERT_EQ(d.decodeString("2[abc]3[cd]ef"), "abcabccdcdcdef");
    ASSERT_EQ(d.decodeString("abc3[cd]xyz"), "abccdcdcdxyz");
}

TEST(Medium, ocean_view)
{
    Leet::Medium::OceanView o;

    auto arr = std::vector<int>{4, 2, 3, 1};
    auto ans = std::vector<int>{0, 2, 3};
    ASSERT_EQ(o.findBuildings(arr), ans);

    arr = {4, 3, 2, 1};
    ans = {0, 1, 2, 3};
    ASSERT_EQ(o.findBuildings(arr), ans);

    arr = {1, 3, 2, 4};
    ans = {3};
    ASSERT_EQ(o.findBuildings(arr), ans);
}

TEST(Medium, largest_merge_string)
{
    Leet::Medium::LargestMergeString l;

    ASSERT_EQ(l.largestMerge("cabaa", "bcaaa"), "cbcabaaaaa");
    ASSERT_EQ(l.largestMerge("abcabc", "abdcaba"), "abdcabcabcaba");
}

TEST(Medium, house_robber)
{
    Leet::Medium::HouseRobber r;

    auto arr = std::vector<int>{2, 1, 1, 2};
    ASSERT_EQ(r.rob(arr), 4);

    arr = {1, 2, 3, 1};
    ASSERT_EQ(r.rob(arr), 4);

    arr = {2, 7, 9, 3, 1};
    ASSERT_EQ(r.rob(arr), 12);
}

TEST(Medium, total_product_except_self)
{
    Leet::Medium::ProductArray p;

    auto arr = std::vector<int>{1, 2, 3, 4};
    auto ans = std::vector<int>{24, 12, 8, 6};

    ASSERT_EQ(p.productExceptSelf(arr), ans);

    arr = {-1, 1, 0, -3, 3};
    ans = {0, 0, 9, 0, 0};

    ASSERT_EQ(p.productExceptSelf(arr), ans);

    arr = {0, 0};
    ans = {0, 0};

    ASSERT_EQ(p.productExceptSelf(arr), ans);
}

TEST(Medium, single_element_sorted_array)
{
    Leet::Medium::SingleElementArray s;

    auto arr = std::vector<int>{1, 1, 2, 3, 3, 4, 4, 8, 8};
    ASSERT_EQ(s.singleNonDuplicate(arr), 2);

    arr = {3, 3, 5, 5, 6, 6, 10, 11, 11};
    ASSERT_EQ(s.singleNonDuplicate(arr), 10);

    arr = {1};
    ASSERT_EQ(s.singleNonDuplicate(arr), 1);

    arr = {1, 1, 2};
    ASSERT_EQ(s.singleNonDuplicate(arr), 2);
}

TEST(Medium, unique_bst)
{
    Leet::Medium::UniqueBST ub;

    ASSERT_EQ(ub.numTrees(3), 5);
    ASSERT_EQ(ub.numTrees(1), 1);
}

TEST(Medium, minimum_rotated_array)
{
    Leet::Medium::MinimumRotatedArray m;

    auto arr = std::vector<int>{3, 4, 5, 1, 2};

    ASSERT_EQ(m.findMin(arr), 1);

    arr = {4, 5, 6, 7, 0, 1, 2};
    ASSERT_EQ(m.findMin(arr), 0);

    arr = {11, 13, 15, 17};
    ASSERT_EQ(m.findMin(arr), 11);
}

TEST(Medium, preorder_serialization)
{
    Leet::Medium::PreorderSerialization p;

    string s = "9,3,4,#,#,1,#,#,2,#,6,#,#";

    ASSERT_TRUE(p.isValidSerialization(s));

    s = "9,#,#,1";
    ASSERT_FALSE(p.isValidSerialization(s));

    s = "9,#,92,#,#";
    ASSERT_TRUE(p.isValidSerialization(s));
}

TEST(Medium, triangle)
{
    Leet::Medium::Triangle t;

    auto arr = std::vector<std::vector<int>>{{2}, {3, 4}, {6, 5, 7}, {4, 1, 8, 3}};

    ASSERT_EQ(t.minimumTotal(arr), 11);

    arr = {{-1}, {2, 3}, {1, -1, -3}};

    ASSERT_EQ(t.minimumTotal(arr), -1);
}

TEST(Medium, contain_water)
{
    Leet::Medium::Most_water w;
    auto arr = std::vector<int>{1, 8, 6, 2, 5, 4, 8, 3, 7};

    ASSERT_EQ(w.maxArea(arr), 49);
}

TEST(Medium, jump_game)
{
    Leet::Medium::JumpGame j;

    auto arr = std::vector<int>{2, 3, 1, 1, 4};
    ASSERT_TRUE(j.canJump(arr));

    arr = std::vector<int>{3, 2, 1, 0, 4};
    ASSERT_FALSE(j.canJump(arr));
}

TEST(Medium, gas_station)
{
    Leet::Medium::GasStation g;

    auto gas = std::vector<int>{1, 2, 3, 4, 5};
    auto cost = std::vector<int>{3, 4, 5, 1, 2};
    ASSERT_EQ(g.canCompleteCircuit(gas, cost), 3);

    gas = std::vector<int>{2, 3, 4};
    cost = std::vector<int>{3, 4, 3};
    ASSERT_EQ(g.canCompleteCircuit(gas, cost), -1);
}

TEST(Medium, integer_replacement)
{
    Leet::Medium::IntegerReplacement i;

    ASSERT_EQ(i.integerReplacement(8), 3);
    ASSERT_EQ(i.integerReplacement(7), 4);
    ASSERT_EQ(i.integerReplacement(4), 2);
    ASSERT_EQ(i.integerReplacement(3), 2);
}

TEST(Medium, queue_by_height)
{
    Leet::Medium::QueueByHeight q;
    vector<vector<int>> v = {{7, 0}, {4, 4}, {7, 1}, {5, 0}, {6, 1}, {5, 2}};
    vector<vector<int>> ans = {{5, 0}, {7, 0}, {5, 2}, {6, 1}, {4, 4}, {7, 1}};

    ASSERT_EQ(q.reconstructQueue(v), ans);
}

TEST(Medium, triplet_subsequence)
{
    Leet::Medium::TripletSubsequence t;

    vector<int> nums = {1, 2, 3, 4, 5};
    ASSERT_TRUE(t.increasingTriplet(nums));

    nums = {5, 4, 3, 2, 1};
    ASSERT_FALSE(t.increasingTriplet(nums));

    nums = {2, 1, 5, 0, 4, 6};
    ASSERT_TRUE(t.increasingTriplet(nums));

    nums = {1, 2, 2147483647};
    ASSERT_TRUE(t.increasingTriplet(nums));
}

TEST(Medium, jump_game_2)
{
    Leet::Medium::JumpGame2 j;

    vector<int> nums = {2, 3, 1, 1, 4};
    ASSERT_EQ(j.jump(nums), 2);

    nums = {2, 3, 0, 1, 4};
    ASSERT_EQ(j.jump(nums), 2);
}

TEST(Medium, H_index)
{
    Leet::Medium::HIndex h;

    vector<int> nums = {3, 0, 6, 1, 5};
    ASSERT_EQ(h.hIndex(nums), 3);

    nums = {1, 3, 1};
    ASSERT_EQ(h.hIndex(nums), 1);
}

TEST(Medium, kth_factor)
{
    Leet::Medium::KthFactor k;

    ASSERT_EQ(k.kthFactor(12, 3), 3);
    ASSERT_EQ(k.kthFactor(7, 2), 7);
    ASSERT_EQ(k.kthFactor(4, 4), -1);
}

TEST(Medium, optimal_partition_string)
{
    Leet::Medium::PartitionString p;

    ASSERT_EQ(p.partitionString("abacaba"), 4);
    ASSERT_EQ(p.partitionString("ssssss"), 6);
}

TEST(Medium, longest_common_prefix)
{
    Leet::Medium::LongestPrefix l;

    vector<string> strs = {"flower", "flow", "flight"};
    ASSERT_EQ(l.longestCommonPrefix(strs), "fl");

    strs = {"dog", "racecar", "car"};
    ASSERT_EQ(l.longestCommonPrefix(strs), "");
}

TEST(Medium, min_deletion_string_balance)
{
    Leet::Medium::MinStringBalance m;

    ASSERT_EQ(m.minimumDeletions("aababbab"), 2);
    ASSERT_EQ(m.minimumDeletions("bbaaaabb"), 2);
}

TEST(Medium, total_hamming_distance)
{
    Leet::Medium::TotalHamming t;

    vector<int> nums = {4, 14, 2};
    ASSERT_EQ(t.totalHammingDistance(nums), 6);

    nums = {4, 14, 4};
    ASSERT_EQ(t.totalHammingDistance(nums), 4);
}

TEST(Medium, break_palindrome)
{
    Leet::Medium::BreakPalindrome b;

    ASSERT_EQ(b.breakPalindrome("abccba"), "aaccba");
    ASSERT_EQ(b.breakPalindrome("a"), "");
}

TEST(Medium, 3sum_closest)
{
    Leet::Medium::ThreeSumClosest t;

    vector<int> nums = {-1, 2, 1, -4};
    ASSERT_EQ(t.threeSumClosest(nums, 1), 2);

    nums = {0, 0, 0};
    ASSERT_EQ(t.threeSumClosest(nums, 1), 0);
}

TEST(Medium, bag_of_tokens)
{
    Leet::Medium::BagOfTokens b;

    vector<int> tokens{200, 100};
    ASSERT_EQ(b.bagOfTokensScore(tokens, 150), 1);

    tokens = {100, 200, 400, 300};
    ASSERT_EQ(b.bagOfTokensScore(tokens, 200), 2);
}

TEST(Medium, min_length_delete_str)
{
    Leet::Medium::MinLengthString m;

    ASSERT_EQ(m.minimumLength("ca"), 2);
    ASSERT_EQ(m.minimumLength("cabaabac"), 0);
    ASSERT_EQ(m.minimumLength("aabccabba"), 3);
    ASSERT_EQ(m.minimumLength("aaaaa"), 0);
    ASSERT_EQ(
        m.minimumLength("bbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbccbcbcbccbbabbb"), 1);
}

TEST(Medium, binary_subarray_sum)
{
    Leet::Medium::BinarySubArraySum b;

    vector<int> nums{1, 0, 1, 0, 1};
    ASSERT_EQ(b.numSubarraysWithSum(nums, 2), 4);

    nums = {0, 0, 0, 0, 0};
    ASSERT_EQ(b.numSubarraysWithSum(nums, 0), 15);
}

TEST(Medium, compare_versions)
{
    Leet::Medium::CompareVersions c;

    ASSERT_EQ(c.compareVersion("1.01", "1.001"), 0);
    ASSERT_EQ(c.compareVersion("1.0", "1.0.0"), 0);
    ASSERT_EQ(c.compareVersion("0.1", "1.1"), -1);
}

TEST(Medium, cows_bulls)
{
    Leet::Medium::CowsBulls c;

    ASSERT_EQ(c.getHint("1807", "7810"), "1A3B");
    ASSERT_EQ(c.getHint("1123", "0111"), "1A1B");
}

TEST(Medium, additive_num)
{
    Leet::Medium::AdditiveNumber a;

    ASSERT_TRUE(a.isAdditiveNumber("112358"));
    ASSERT_TRUE(a.isAdditiveNumber("199100199"));
}

TEST(Medium, count_and_say)
{
    Leet::Medium::CountSay c;

    ASSERT_EQ(c.countAndSay(4), "1211");
    ASSERT_EQ(c.countAndSay(1), "1");
}

TEST(Medium, binary_array_one)
{
    Leet::Medium::BinaryOneArray b;

    std::vector<int> arr{0, 1, 1, 1, 0, 0};
    ASSERT_EQ(b.minOperations(arr), 3);

    arr = {0, 1, 1, 1};
    ASSERT_EQ(b.minOperations(arr), -1);
}

TEST(Medium, first_last_elm_array)
{
    Leet::Medium::FirstLastElem f;

    std::vector<int> arr{5, 7, 7, 8, 8, 10};
    std::vector<int> range{3, 4};
    ASSERT_EQ(f.searchRange(arr, 8), range);

    arr = {5, 7, 7, 8, 8, 10};
    range = {-1, -1};
    ASSERT_EQ(f.searchRange(arr, 6), range);

    arr = {};
    range = {-1, -1};
    ASSERT_EQ(f.searchRange(arr, 0), range);
}

TEST(Medium, reverse_string_in_parens)
{
    Leet::Medium::ReverseStringParens r;

    ASSERT_EQ(r.reverseParentheses("(abcd)"), "dcba");
    ASSERT_EQ(r.reverseParentheses("(u(love)i)"), "iloveu");
    ASSERT_EQ(r.reverseParentheses("(ed(et(oc))el)"), "leetcode");
}

TEST(Medium, can_array_sort)
{
    Leet::Medium::ArrayCanBeSorted a;

    std::vector<int> arr{8, 4, 2, 30, 15};
    ASSERT_TRUE(a.canSortArray(arr));
}

TEST(Medium, city_smallest_number_neighbors)
{
    Leet::Medium::CitySmallestNeighbors c;

    vector<vector<int>> graph = {{0, 1, 3}, {1, 2, 1}, {1, 3, 4}, {2, 3, 1}};
    ASSERT_EQ(c.findTheCity(4, graph, 4), 3);

    graph = {{0, 1, 2}, {0, 4, 8}, {1, 2, 3}, {1, 4, 2}, {2, 3, 1}, {3, 4, 1}};
    ASSERT_EQ(c.findTheCity(5, graph, 2), 0);
}

TEST(Medium, longest_repeating_char_replacement)
{
    Leet::Medium::LongestRepeatingReplace l;

    ASSERT_EQ(l.characterReplacement("ABAB", 2), 4);
    ASSERT_EQ(l.characterReplacement("AABABBA", 1), 4);
}

TEST(Medium, reverse_polish_notation)
{
    Leet::Medium::PolishNotation p;

    vector<std::string> values{"2", "1", "+", "3", "*"};
    ASSERT_EQ(p.evalRPN(values), 9);

    values = {"4", "13", "5", "/", "+"};
    ASSERT_EQ(p.evalRPN(values), 6);

    values = {"10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"};
    ASSERT_EQ(p.evalRPN(values), 22);
}

TEST(Medium, daily_temperatures)
{
    Leet::Medium::DailyTemps d;

    vector<int> temps{73, 74, 75, 71, 69, 72, 76, 73};
    vector<int> answer{1, 1, 4, 2, 1, 1, 0, 0};
    ASSERT_EQ(d.dailyTemperatures(temps), answer);

    temps = {30, 40, 50, 60};
    answer = {1, 1, 1, 0};
    ASSERT_EQ(d.dailyTemperatures(temps), answer);
}

TEST(Medium, min_diff_3_moves)
{
    Leet::Medium::MinDiff3Moves m;

    vector<int> arr{5, 3, 2, 4};
    ASSERT_EQ(m.minDifference(arr), 0);

    arr = {1, 5, 0, 10, 14};
    ASSERT_EQ(m.minDifference(arr), 1);

    arr = {3, 100, 20};
    ASSERT_EQ(m.minDifference(arr), 0);
}

TEST(Medium, shortest_dist_road_query)
{
    Leet::Medium::ShortestDistRoadQuery s;

    vector<vector<int>> queries{{2, 4}, {0, 2}, {0, 4}};
    vector<int> dist{3, 2, 1};
    ASSERT_EQ(s.shortestDistanceAfterQueries(5, queries), dist);

    queries = {{0, 3}, {0, 2}};
    dist = {1, 1};
    ASSERT_EQ(s.shortestDistanceAfterQueries(4, queries), dist);
}

TEST(Medium, number_good_splits)
{
    Leet::Medium::NumberGoodSplits n;

    ASSERT_EQ(n.numSplits("aacaba"), 2);
    ASSERT_EQ(n.numSplits("abcd"), 1);
}

TEST(Medium, longest_substring_k_repeating)
{
    Leet::Medium::LongestSubstringKRepeating l;

    ASSERT_EQ(l.longestSubstring("aaabb", 3), 3);
    ASSERT_EQ(l.longestSubstring("ababbc", 2), 5);
}

TEST(Medium, alphabet_board_path)
{
    Leet::Medium::AlphabetBoardPath a;

    ASSERT_EQ(a.alphabetBoardPath("leet"), "DDR!UURRR!!DDD!");
    ASSERT_EQ(a.alphabetBoardPath("code"), "RR!DDRR!LUU!R!");
}

TEST(Medium, max_distance_arrays)
{
    Leet::Medium::MaxDistArrays m;

    vector<vector<int>> arr{{1, 2, 3}, {4, 5}, {1, 2, 3}};
    ASSERT_EQ(m.maxDistance(arr), 4);
}

TEST(Medium, hash_divided_string)
{
    Leet::Medium::HashDividedString h;

    ASSERT_EQ(h.stringHash("abcd", 2), "bf");
    ASSERT_EQ(h.stringHash("mxz", 3), "i");
}

TEST(Medium, hand_of_straights)
{
    Leet::Medium::HandOfStraight h;

    vector<int> hand{1, 2, 3, 6, 2, 3, 4, 7, 8};
    ASSERT_TRUE(h.isNStraightHand(hand, 3));

    hand = {1, 2, 3, 4, 5};
    ASSERT_FALSE(h.isNStraightHand(hand, 3));
}

TEST(Medium, valid_parenthesis_str)
{
    Leet::Medium::ValidParenString v;

    ASSERT_TRUE(v.checkValidString("()"));
    ASSERT_TRUE(v.checkValidString("(*)"));
    ASSERT_TRUE(v.checkValidString("(*))"));
}

TEST(Medium, longest_palindrom_subseq)
{
    Leet::Medium::LongestPalindromSubSeq l;

    ASSERT_EQ(l.longestPalindromeSubseq("bbbab"), 4);
    ASSERT_EQ(l.longestPalindromeSubseq("cbbd"), 2);
}

TEST(Medium, count_palindrom_substring)
{
    Leet::Medium::PalindromicCountSubstr p;

    ASSERT_EQ(p.countSubstrings("abc"), 3);
    ASSERT_EQ(p.countSubstrings("aaa"), 6);
}

TEST(Medium, longest_substr_even_vowels)
{
    Leet::Medium::LongestSubstrEvenVowels l;

    ASSERT_EQ(l.findTheLongestSubstring("eleetminicoworoep"), 13);
    ASSERT_EQ(l.findTheLongestSubstring("leetcodeisgreat"), 5);
    ASSERT_EQ(l.findTheLongestSubstring("bcbcbc"), 6);
}